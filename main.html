<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Paper Plane Simulator</title>
  <style>
    :root {
      --primary: #3498db;
      --secondary: #2ecc71;
      --dark: #2c3e50;
      --light: #ecf0f1;
      --accent: #e74c3c;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    body {
      background-color: var(--light);
      color: var(--dark);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
    }
    
    h1 {
      font-size: 2.5rem;
      margin-bottom: 10px;
      color: var(--dark);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .container {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 1200px;
      gap: 20px;
    }
    
    .simulation-area {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      width: 100%;
    }
    
    .canvas-container {
      position: relative;
      background: linear-gradient(to bottom, #87CEEB, #e0f7fa);
      border-radius: 10px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      overflow: hidden;
      width: 600px;
      height: 400px;
    }
    
    #simulationCanvas {
      width: 100%;
      height: 100%;
    }
    
    .controls {
      background-color: white;
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
      width: 400px;
      max-width: 100%;
    }
    
    .control-group {
      margin-bottom: 15px;
    }
    
    .control-group h3 {
      margin-bottom: 10px;
      color: var(--dark);
      font-size: 1.2rem;
      border-bottom: 2px solid var(--primary);
      padding-bottom: 5px;
    }
    
    .slider-control {
      margin-bottom: 12px;
    }
    
    .slider-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    
    .slider-control label span {
      font-weight: bold;
      color: var(--primary);
    }
    
    .slider-control input[type="range"] {
      width: 100%;
      height: 8px;
      -webkit-appearance: none;
      appearance: none;
      background: #e0e0e0;
      outline: none;
      border-radius: 4px;
    }
    
    .slider-control input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: var(--primary);
      border-radius: 50%;
      cursor: pointer;
      transition: background 0.3s;
    }
    
    .slider-control input[type="range"]::-webkit-slider-thumb:hover {
      background: var(--secondary);
    }
    
    .buttons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    
    button {
      padding: 12px 24px;
      border: none;
      border-radius: 5px;
      font-size: 1rem;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    #launchBtn {
      background-color: var(--secondary);
      color: white;
    }
    
    #resetBtn {
      background-color: var(--accent);
      color: white;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    
    .parameter-display {
      background-color: rgba(255, 255, 255, 0.8);
      padding: 10px;
      border-radius: 5px;
      position: absolute;
      top: 10px;
      right: 10px;
      font-size: 0.9rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .parameter-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 5px;
    }
    
    .parameter-item span:first-child {
      font-weight: bold;
      margin-right: 10px;
    }
    
    @media (max-width: 768px) {
      .simulation-area {
        flex-direction: column;
        align-items: center;
      }
      
      .canvas-container, .controls {
        width: 100%;
      }
      
      .canvas-container {
        height: 300px;
      }
    }
    
    .paper-plane {
      position: absolute;
      width: 40px;
      height: 40px;
      transform-origin: center;
      transition: transform 0.1s;
    }
    
    .force-vector {
      position: absolute;
      height: 2px;
      background-color: red;
      transform-origin: left center;
    }
    
    .vector-label {
      position: absolute;
      font-size: 12px;
      color: white;
      text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
      white-space: nowrap;
    }
    
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Paper Plane Simulator</h1>
    <p>Adjust the parameters and launch your paper plane!</p>
  </div>
  
  <div class="container">
    <div class="simulation-area">
      <div class="canvas-container">
        <canvas id="simulationCanvas"></canvas>
        <div id="message"></div>
        <div class="parameter-display">
          <div class="parameter-item">
            <span>Status:</span>
            <span id="statusDisplay">Ready</span>
          </div>
          <div class="parameter-item">
            <span>Height:</span>
            <span id="heightDisplay">0 m</span>
          </div>
          <div class="parameter-item">
            <span>Distance:</span>
            <span id="distanceDisplay">0 m</span>
          </div>
          <div class="parameter-item">
            <span>Speed:</span>
            <span id="speedDisplay">0 m/s</span>
          </div>
        </div>
      </div>
      
      <div class="controls">
        <div class="control-group">
          <h3>Launch Parameters</h3>
          <div class="slider-control">
            <label>
              Initial Velocity
              <span id="velocityValue">5.0 m/s</span>
            </label>
            <input type="range" id="velocitySlider" min="1" max="10" step="0.1" value="5">
          </div>
          <div class="slider-control">
            <label>
              Launch Angle
              <span id="angleValue">15째</span>
            </label>
            <input type="range" id="angleSlider" min="0" max="45" step="1" value="15">
          </div>
          <div class="slider-control">
            <label>
              Initial Height
              <span id="heightValue">1.5 m</span>
            </label>
            <input type="range" id="heightSlider" min="0.5" max="5" step="0.1" value="1.5">
          </div>
        </div>
        
        <div class="control-group">
          <h3>Plane Properties</h3>
          <div class="slider-control">
            <label>
              Wing Area
              <span id="wingAreaValue">1.0</span>
            </label>
            <input type="range" id="wingAreaSlider" min="0.5" max="2" step="0.1" value="1">
          </div>
          <div class="slider-control">
            <label>
              Weight
              <span id="weightValue">1.0</span>
            </label>
            <input type="range" id="weightSlider" min="0.5" max="2" step="0.1" value="1">
          </div>
          <div class="slider-control">
            <label>
              Nose Angle
              <span id="noseAngleValue">0째</span>
            </label>
            <input type="range" id="noseAngleSlider" min="-10" max="10" step="1" value="0">
          </div>
        </div>
        
        <div class="control-group">
          <h3>Environment</h3>
          <div class="slider-control">
            <label>
              Wind Speed
              <span id="windSpeedValue">0.0 m/s</span>
            </label>
            <input type="range" id="windSpeedSlider" min="-5" max="5" step="0.1" value="0">
          </div>
          <div class="slider-control">
            <label>
              Air Density
              <span id="airDensityValue">1.0</span>
            </label>
            <input type="range" id="airDensitySlider" min="0.7" max="1.3" step="0.05" value="1">
          </div>
        </div>
        
        <div class="buttons">
          <button id="launchBtn">LAUNCH</button>
          <button id="resetBtn">RESET</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Get DOM elements
      const canvas = document.getElementById('simulationCanvas');
      const ctx = canvas.getContext('2d');
      const launchBtn = document.getElementById('launchBtn');
      const resetBtn = document.getElementById('resetBtn');
      const message = document.getElementById('message');
      
      // Status displays
      const statusDisplay = document.getElementById('statusDisplay');
      const heightDisplay = document.getElementById('heightDisplay');
      const distanceDisplay = document.getElementById('distanceDisplay');
      const speedDisplay = document.getElementById('speedDisplay');
      
      // Sliders and their value displays
      const sliders = {
        velocity: {
          slider: document.getElementById('velocitySlider'),
          display: document.getElementById('velocityValue')
        },
        angle: {
          slider: document.getElementById('angleSlider'),
          display: document.getElementById('angleValue')
        },
        height: {
          slider: document.getElementById('heightSlider'),
          display: document.getElementById('heightValue')
        },
        wingArea: {
          slider: document.getElementById('wingAreaSlider'),
          display: document.getElementById('wingAreaValue')
        },
        weight: {
          slider: document.getElementById('weightSlider'),
          display: document.getElementById('weightValue')
        },
        noseAngle: {
          slider: document.getElementById('noseAngleSlider'),
          display: document.getElementById('noseAngleValue')
        },
        windSpeed: {
          slider: document.getElementById('windSpeedSlider'),
          display: document.getElementById('windSpeedValue')
        },
        airDensity: {
          slider: document.getElementById('airDensitySlider'),
          display: document.getElementById('airDensityValue')
        }
      };
      
      // Set canvas size
      function resizeCanvas() {
        canvas.width = canvas.parentElement.clientWidth;
        canvas.height = canvas.parentElement.clientHeight;
      }
      
      // Initial resize
      resizeCanvas();
      
      // Listen for window resize
      window.addEventListener('resize', resizeCanvas);
      
      // Simulation state
      let simulationActive = false;
      let animationFrameId = null;
      
      // Paper plane properties
      const plane = {
        x: 0,
        y: 0,
        velocity: 5,
        angle: 15,
        height: 1.5,
        vx: 0,
        vy: 0,
        wingArea: 1,
        weight: 1,
        noseAngle: 0,
        rotation: 0,
        width: 40,
        height: 25,
        path: [],
        forces: {
          lift: { magnitude: 0, angle: 0 },
          drag: { magnitude: 0, angle: 0 },
          gravity: { magnitude: 0, angle: 0 },
          wind: { magnitude: 0, angle: 0 }
        }
      };
      
      // Environment properties
      const environment = {
        gravity: 9.81,
        windSpeed: 0,
        airDensity: 1.0,
        ground: 0,
        scale: 20 // pixels per meter
      };
      
      // Update slider value displays
      function updateSliderDisplays() {
        sliders.velocity.display.textContent = `${sliders.velocity.slider.value} m/s`;
        sliders.angle.display.textContent = `${sliders.angle.slider.value}째`;
        sliders.height.display.textContent = `${sliders.height.slider.value} m`;
        sliders.wingArea.display.textContent = sliders.wingArea.slider.value;
        sliders.weight.display.textContent = sliders.weight.slider.value;
        sliders.noseAngle.display.textContent = `${sliders.noseAngle.slider.value}째`;
        sliders.windSpeed.display.textContent = `${sliders.windSpeed.slider.value} m/s`;
        sliders.airDensity.display.textContent = sliders.airDensity.slider.value;
      }
      
      // Add slider event listeners
      Object.keys(sliders).forEach(key => {
        sliders[key].slider.addEventListener('input', function() {
          updateSliderDisplays();
          updatePlaneProperties();
          if (!simulationActive) {
            drawScene();
          }
        });
      });
      
      // Update plane properties from sliders
      function updatePlaneProperties() {
        plane.velocity = parseFloat(sliders.velocity.slider.value);
        plane.angle = parseFloat(sliders.angle.slider.value);
        plane.height = parseFloat(sliders.height.slider.value);
        plane.wingArea = parseFloat(sliders.wingArea.slider.value);
        plane.weight = parseFloat(sliders.weight.slider.value);
        plane.noseAngle = parseFloat(sliders.noseAngle.slider.value);
        environment.windSpeed = parseFloat(sliders.windSpeed.slider.value);
        environment.airDensity = parseFloat(sliders.airDensity.slider.value);
      }
      
      // Initialize simulation
      function initializeSimulation() {
        updatePlaneProperties();
        
        // Convert angle to radians
        const angleRad = (plane.angle * Math.PI) / 180;
        
        // Set initial position
        plane.x = 50;
        plane.y = canvas.height - (plane.height * environment.scale) - 10;
        
        // Set initial velocity components
        plane.vx = plane.velocity * Math.cos(angleRad);
        plane.vy = -plane.velocity * Math.sin(angleRad);
        
        // Reset path
        plane.path = [];
        
        // Set initial rotation
        plane.rotation = -plane.angle;
        
        // Calculate initial forces
        calculateForces();
        
        // Update displays
        heightDisplay.textContent = '0 m';
        distanceDisplay.textContent = '0 m';
        speedDisplay.textContent = `${plane.velocity.toFixed(1)} m/s`;
        statusDisplay.textContent = 'Ready';
      }
      
      // Draw paper plane
      function drawPlane(x, y, rotation) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate((rotation * Math.PI) / 180);
        
        // Draw the paper plane body
        ctx.beginPath();
        ctx.moveTo(20, 0); // Nose
        ctx.lineTo(-15, -10); // Left Wing
        ctx.lineTo(-10, 0); // Back middle
        ctx.lineTo(-15, 10); // Right Wing
        ctx.closePath();
        
        // Fill with gradient
        const gradient = ctx.createLinearGradient(-15, 0, 20, 0);
        gradient.addColorStop(0, '#white');
        gradient.addColorStop(1, '#f0f0f0');
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Add fold line
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        ctx.lineTo(0, 0);
        ctx.strokeStyle = '#ccc';
        ctx.stroke();
        
        ctx.restore();
      }
      
      // Draw force vectors
      function drawForceVectors() {
        const scale = 3; // Scale for visualization
        const centerX = plane.x;
        const centerY = plane.y;
        
        // Draw lift vector
        drawVector(
          centerX, 
          centerY, 
          plane.forces.lift.magnitude * scale, 
          90 + plane.rotation, 
          'rgba(0, 255, 0, 0.7)', 
          'Lift'
        );
        
        // Draw drag vector
        drawVector(
          centerX, 
          centerY, 
          plane.forces.drag.magnitude * scale, 
          180 + plane.rotation, 
          'rgba(255, 0, 0, 0.7)', 
          'Drag'
        );
        
        // Draw gravity vector
        drawVector(
          centerX, 
          centerY, 
          plane.forces.gravity.magnitude * scale, 
          -90, 
          'rgba(0, 0, 255, 0.7)', 
          'Gravity'
        );
        
        // Draw wind vector if significant
        if (Math.abs(environment.windSpeed) > 0.1) {
          drawVector(
            centerX, 
            centerY, 
            Math.abs(plane.forces.wind.magnitude) * scale, 
            environment.windSpeed > 0 ? 0 : 180, 
            'rgba(255, 165, 0, 0.7)', 
            'Wind'
          );
        }
      }
      
      // Helper to draw a vector
      function drawVector(x, y, length, angleDeg, color, label) {
        if (length < 1) return; // Don't draw very small vectors
        
        const angleRad = (angleDeg * Math.PI) / 180;
        const endX = x + length * Math.cos(angleRad);
        const endY = y + length * Math.sin(angleRad);
        
        // Draw line
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(endX, endY);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw arrowhead
        const arrowSize = 7;
        const arrowAngle = Math.PI / 7;
        
        ctx.beginPath();
        ctx.moveTo(endX, endY);
        ctx.lineTo(
          endX - arrowSize * Math.cos(angleRad - arrowAngle),
          endY - arrowSize * Math.sin(angleRad - arrowAngle)
        );
        ctx.lineTo(
          endX - arrowSize * Math.cos(angleRad + arrowAngle),
          endY - arrowSize * Math.sin(angleRad + arrowAngle)
        );
        ctx.closePath();
        ctx.fillStyle = color;
        ctx.fill();
        
        // Draw label
        const labelX = x + (length / 2) * Math.cos(angleRad);
        const labelY = y + (length / 2) * Math.sin(angleRad) - 10;
        
        ctx.fillStyle = color;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(label, labelX, labelY);
      }
      
      // Draw ground
      function drawGround() {
        const groundY = canvas.height - 10;
        
        // Draw ground line
        ctx.beginPath();
        ctx.moveTo(0, groundY);
        ctx.lineTo(canvas.width, groundY);
        ctx.strokeStyle = '#3a3a3a';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Draw ground pattern
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(0, groundY, canvas.width, 10);
      }
      
      // Draw flight path
      function drawPath() {
        if (plane.path.length < 2) return;
        
        ctx.beginPath();
        ctx.moveTo(plane.path[0].x, plane.path[0].y);
        
        for (let i = 1; i < plane.path.length; i++) {
          ctx.lineTo(plane.path[i].x, plane.path[i].y);
        }
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
      }
      
      // Calculate forces acting on the plane
      function calculateForces() {
        const speed = Math.sqrt(plane.vx * plane.vx + plane.vy * plane.vy);
        const angleOfAttack = (plane.rotation + plane.noseAngle) * (Math.PI / 180);
        
        // Calculate lift coefficient based on angle of attack
        // Simplified model: lift increases with angle of attack up to a point, then decreases
        const liftCoefficient = Math.sin(2 * angleOfAttack) * plane.wingArea;
        
        // Calculate drag coefficient
        // Simplified model: drag increases with angle of attack and with wing area
        const dragCoefficient = 0.05 + 0.1 * plane.wingArea + 0.2 * Math.abs(Math.sin(angleOfAttack));
        
        // Calculate lift force
        const liftForce = 0.5 * environment.airDensity * speed * speed * liftCoefficient;
        
        // Calculate drag force
        const dragForce = 0.5 * environment.airDensity * speed * speed * dragCoefficient;
        
        // Calculate gravity force
        const gravityForce = plane.weight * environment.gravity;
        
        // Calculate wind force
        const windForce = 0.5 * environment.airDensity * environment.windSpeed * environment.windSpeed * 0.1 * plane.wingArea;
        
        // Store forces
        plane.forces.lift.magnitude = liftForce;
        plane.forces.drag.magnitude = dragForce;
        plane.forces.gravity.magnitude = gravityForce;
        plane.forces.wind.magnitude = windForce;
      }
      
      // Update plane physics
      function updatePhysics(deltaTime) {
        // Calculate forces
        calculateForces();
        
        // Calculate acceleration from forces
        const accelerationX = (
          -plane.forces.drag.magnitude * Math.cos(plane.rotation * Math.PI / 180) +
          plane.forces.lift.magnitude * Math.sin(plane.rotation * Math.PI / 180) +
          plane.forces.wind.magnitude * Math.sign(environment.windSpeed)
        ) / plane.weight;
        
        const accelerationY = (
          plane.forces.gravity.magnitude -
          plane.forces.lift.magnitude * Math.cos(plane.rotation * Math.PI / 180) -
          plane.forces.drag.magnitude * Math.sin(plane.rotation * Math.PI / 180)
        ) / plane.weight;
        
        // Update velocity
        plane.vx += accelerationX * deltaTime;
        plane.vy += accelerationY * deltaTime;
        
        // Update position
        plane.x += plane.vx * deltaTime * environment.scale;
        plane.y += plane.vy * deltaTime * environment.scale;
        
        // Calculate speed for display
        const speed = Math.sqrt(plane.vx * plane.vx + plane.vy * plane.vy);
        
        // Update rotation based on velocity
        plane.rotation = Math.atan2(plane.vy, plane.vx) * (180 / Math.PI);
        
        // Add current position to path
        if (simulationActive) {
          plane.path.push({ x: plane.x, y: plane.y });
          
          // Limit path length to prevent performance issues
          if (plane.path.length > 100) {
            plane.path.shift();
          }
        }
        
        // Update displays
        const groundY = canvas.height - 10;
        const heightMeters = Math.max(0, (groundY - plane.y) / environment.scale);
        const distanceMeters = (plane.x - 50) / environment.scale;
        
        heightDisplay.textContent = `${heightMeters.toFixed(1)} m`;
        distanceDisplay.textContent = `${distanceMeters.toFixed(1)} m`;
        speedDisplay.textContent = `${speed.toFixed(1)} m/s`;
        
        // Check for collision with ground
        if (plane.y >= groundY) {
          endSimulation('Landed!');
        }
        
        // Check if plane has gone off screen
        if (plane.x > canvas.width || plane.x < 0 || plane.y < 0) {
          endSimulation('Out of bounds!');
        }
      }
      
      // Draw the simulation scene
      function drawScene() {
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Draw ground
        drawGround();
        
        // Draw flight path
        drawPath();
        
        // Draw plane
        drawPlane(plane.x, plane.y, plane.rotation);
        
        // Draw force vectors
        drawForceVectors();
      }
      
      // Main animation loop
      function animate(timestamp) {
        if (!simulationActive) return;
        
        // Calculate time delta
        if (!animate.lastTimestamp) {
          animate.lastTimestamp = timestamp;
        }
        const deltaTime = (timestamp - animate.lastTimestamp) / 1000; // Convert to seconds
        animate.lastTimestamp = timestamp;
        
        // Update physics
        updatePhysics(deltaTime);
        
        // Draw scene
        drawScene();
        
        // Continue animation
        animationFrameId = requestAnimationFrame(animate);
      }
      
      // Launch the plane
      function launchPlane() {
        if (simulationActive) return;
        
        initializeSimulation();
        simulationActive = true;
        statusDisplay.textContent = 'Flying';
        animate.lastTimestamp = null;
        animationFrameId = requestAnimationFrame(animate);
        
        // Disable launch button during flight
        launchBtn.disabled = true;
      }
      
      // End the simulation
      function endSimulation(msg) {
        simulationActive = false;
        statusDisplay.textContent = 'Finished';
        cancelAnimationFrame(animationFrameId);
        
        // Show message
        message.textContent = msg;
        message.style.opacity = 1;
        
        // Enable launch button
        launchBtn.disabled = false;
        
        // Hide message after delay
        setTimeout(() => {
          message.style.opacity = 0;
        }, 2000);
      }
      
      // Reset the simulation
      function resetSimulation() {
        simulationActive = false;
        statusDisplay.textContent = 'Ready';
        cancelAnimationFrame(animationFrameId);
        
        // Reset plane position
        initializeSimulation();
        
        // Draw initial scene
        drawScene();
        
        // Enable launch button
        launchBtn.disabled = false;
        
        // Hide message
        message.style.opacity = 0;
      }
      
      // Event listeners for buttons
      launchBtn.addEventListener('click', launchPlane);
      resetBtn.addEventListener('click', resetSimulation);
      
      // Initialize
      updateSliderDisplays();
      initializeSimulation();
      drawScene();
    });
  </script>
</body>
</html>
